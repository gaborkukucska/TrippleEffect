// START OF FILE static/js/eventHandler.js

/**
 * @module eventHandler
 * @description Handles events like button clicks, input changes, and WebSocket messages.
 * Relies on uiModule for DOM updates, apiClient for API calls,
 * and websocketModule for sending messages.
 */

import { uiModule } from './uiModule.js';
import { apiClient } from './apiClient.js';
import { websocketModule } from './websocketModule.js';
import { attachFile, clearAttachedFile, getAttachedFile } from './fileManager.js';

/**
 * Handles incoming WebSocket messages and routes them to appropriate UI updates.
 * @param {MessageEvent} event - The WebSocket message event.
 */
function handleWebSocketMessage(event) {
    try {
        const rawData = event.data;
        // console.debug("Raw WS Message:", rawData); // Optional: log raw data
        const parsedData = JSON.parse(rawData);
        // console.log("Parsed WS Message:", parsedData); // Log parsed data

        // --- Message Routing Logic ---
        switch (parsedData.type) {
            case 'user': // Should ideally not receive 'user' type from backend, but handle defensively
                console.warn("Received unexpected 'user' type message from backend.");
                uiModule.addMessageToConversation('user', parsedData.content); // Display in main chat
                break;

            case 'agent_response':
                // Route based on agent ID
                if (parsedData.agent_id === 'admin_ai') {
                    // Admin AI responses go to the main conversation area
                    uiModule.addMessageToConversation(parsedData.agent_id, parsedData.content, parsedData.type);
                } else {
                    // Other agent responses go to the internal communications view
                    uiModule.addLogEntry(parsedData, 'log-agent-message'); // Add to internal comms
                }
                break;

            case 'response_chunk':
                // Append chunks to the conversation area (assumes target is Admin AI for now)
                // TODO: Enhance if chunks need routing based on agent_id for internal view? Unlikely for now.
                uiModule.appendAgentResponseChunk(parsedData.agent_id, parsedData.content);
                break;

            case 'agent_status_update':
                // Update the agent status list (no change needed in handler)
                uiModule.updateAgentStatusList(parsedData.status);
                break;

            case 'status':
                // General status messages go to internal comms
                // Special handling for initial connection message
                if (parsedData.message === "Connected to TrippleEffect backend!") {
                    uiModule.updateInitialConnectionStatus(true);
                } else {
                    uiModule.addLogEntry(parsedData, 'status');
                }
                break;

            case 'error':
                // Error messages go to internal comms
                uiModule.addLogEntry(parsedData, 'error');
                break;

            case 'tool_requests':
            case 'tool_results':
                // Tool interactions go to internal comms
                uiModule.addLogEntry(parsedData, 'log-tool-use');
                break;

            case 'plan_generated':
                // Plan generation messages go to internal comms
                // Display the plan content clearly
                uiModule.addLogEntry({
                    ...parsedData,
                    content: `[Plan Generated by ${parsedData.agent_id}]:\n${parsedData.plan_content}`
                }, 'status', true); // Treat as status, use code block formatting
                 // Add the framework approval message right after
                 uiModule.addLogEntry({
                     agent_id: 'Framework',
                     content: '[Framework Approval] Plan approved. Proceed with execution.',
                     timestamp: new Date().toISOString() // Add approximate timestamp
                 }, 'status');
                break;

            case 'system_event':
                 // System events (like session save/load) go to internal comms
                 uiModule.addLogEntry({
                     ...parsedData,
                     content: `[System Event: ${parsedData.event}] ${parsedData.message}`
                 }, 'status');
                 // Handle session load/save confirmation in the session view as well
                 if (parsedData.event === 'session_saved' || parsedData.event === 'session_loaded') {
                     uiModule.displaySessionStatus(parsedData.message, true); // Show success message
                 }
                 break;

            case 'agent_added': // Handled by agent_status_update now? Keep for redundancy? Let's rely on status update.
                console.debug("Agent Added message type received (handled by agent_status_update):", parsedData);
                // uiModule.addAgentToList(parsedData.agent_id, parsedData.config, parsedData.team); // Redundant if status update works
                break;
            case 'agent_deleted': // Handled by agent_status_update now?
                 console.debug("Agent Deleted message type received (handled by agent_status_update):", parsedData);
                // uiModule.removeAgentFromList(parsedData.agent_id); // Redundant if status update works
                break;
            case 'team_created': // Display in internal comms?
            case 'team_deleted':
            case 'agent_moved_team':
                 console.debug("Team management message received:", parsedData);
                 uiModule.addLogEntry({
                     ...parsedData,
                     content: `[Team Update] Type: ${parsedData.type}, Details: ${JSON.stringify(parsedData)}`
                 }, 'status');
                 break;

            default:
                console.warn("Received unknown WebSocket message type:", parsedData.type, parsedData);
                // Display unknown messages in internal comms for debugging
                uiModule.addLogEntry(parsedData, 'status');
        }

    } catch (error) {
        console.error("Failed to parse WebSocket message or error during handling:", error);
        // Display raw data in internal comms if parsing fails
        uiModule.addLogEntry({ content: `Failed to process message: ${event.data}` }, 'error');
    }
}


/**
 * Handles sending the message from the input field.
 */
function handleSendMessage() {
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const fileInfo = getAttachedFile();
    const messageText = messageInput.value.trim();

    if (!messageText && !fileInfo) return; // Don't send empty messages

    sendButton.disabled = true; // Disable button while sending

    // --- Message Construction ---
    let messageToSend;
    if (fileInfo) {
        messageToSend = JSON.stringify({
            type: "user_message_with_file",
            text: messageText,
            filename: fileInfo.name,
            file_content: fileInfo.content
        });
        // Add visual representation of file message to conversation
        uiModule.addMessageToConversation('user', `[Sent File: ${fileInfo.name}]\n${messageText}`);
    } else {
         messageToSend = messageText;
         // Add user message directly to conversation
         uiModule.addMessageToConversation('user', messageText);
    }
    // --- End Message Construction ---


    // Send message via WebSocket
    if (websocketModule.getWebSocket()?.readyState === WebSocket.OPEN) {
        websocketModule.sendMessage(messageToSend);
        // Clear input and file only after successful send logic starts
        messageInput.value = '';
        clearAttachedFile(); // Clear file after sending
        uiModule.updateFileInfoArea(null); // Update UI
        uiModule.resetChatInputHeight(); // Reset height after sending
    } else {
        console.error("WebSocket is not connected.");
        uiModule.addMessageToConversation('system', "[Error: WebSocket disconnected. Cannot send message.]");
    }

    // Re-enable button slightly later to prevent rapid clicks
    setTimeout(() => {
        sendButton.disabled = false;
    }, 500);
}

/**
 * Initializes all event listeners for the application.
 */
function initializeEventListeners() {
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const attachFileButton = document.getElementById('attach-file-button');
    const fileInput = document.getElementById('file-input');
    const fileInfoArea = document.getElementById('file-info-area');
    const navButtons = document.querySelectorAll('.nav-button');
    const projectSelect = document.getElementById('project-select');
    const sessionSelect = document.getElementById('session-select');
    const loadSessionButton = document.getElementById('load-session-button');
    const saveSessionButton = document.getElementById('save-session-button');
    const addAgentButton = document.getElementById('add-agent-button');
    const agentForm = document.getElementById('agent-form');
    const refreshConfigButton = document.getElementById('refresh-config-button');

    // Send message on button click
    sendButton?.addEventListener('click', handleSendMessage);

    // Send message on Enter key press in textarea (Shift+Enter for newline)
    messageInput?.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault(); // Prevent newline
            handleSendMessage();
        }
        uiModule.adjustChatInputHeight(); // Adjust height on keydown
    });
    // Adjust height on input/paste as well
    messageInput?.addEventListener('input', uiModule.adjustChatInputHeight);
    messageInput?.addEventListener('paste', () => setTimeout(uiModule.adjustChatInputHeight, 0));


    // Attach file button triggers hidden file input
    attachFileButton?.addEventListener('click', () => fileInput?.click());

    // Handle file selection
    fileInput?.addEventListener('change', attachFile);


    // Navigation button clicks
    navButtons.forEach(button => {
        button.addEventListener('click', () => {
            const viewId = button.getAttribute('data-view');
            uiModule.switchView(viewId);
        });
    });

    // Session Management Listeners
    projectSelect?.addEventListener('change', async () => {
        const selectedProject = projectSelect.value;
        uiModule.clearSessionStatus();
        if (selectedProject) {
            await uiModule.populateSessionDropdown(selectedProject);
            sessionSelect.disabled = false;
            loadSessionButton.disabled = true; // Disable load until a session is chosen
        } else {
            sessionSelect.innerHTML = '<option value="">-- Select Project First --</option>';
            sessionSelect.disabled = true;
            loadSessionButton.disabled = true;
        }
    });

    sessionSelect?.addEventListener('change', () => {
        loadSessionButton.disabled = !sessionSelect.value; // Enable load button only if a session is selected
         uiModule.clearSessionStatus();
    });

    loadSessionButton?.addEventListener('click', async () => {
        const projectName = projectSelect.value;
        const sessionName = sessionSelect.value;
        if (projectName && sessionName) {
            uiModule.setSessionLoadingState(true);
            await apiClient.loadSession(projectName, sessionName); // Let WS message handle success/error display
            uiModule.setSessionLoadingState(false);
        } else {
            uiModule.displaySessionStatus("Please select both a project and a session.", false);
        }
    });

    saveSessionButton?.addEventListener('click', async () => {
        const projectName = document.getElementById('save-project-name').value.trim();
        const sessionName = document.getElementById('save-session-name').value.trim() || null; // Send null if empty
        if (projectName) {
            uiModule.setSessionLoadingState(true);
            await apiClient.saveSession(projectName, sessionName); // Let WS message handle success/error display
            uiModule.setSessionLoadingState(false);
            // Optionally refresh project list after saving
            await uiModule.populateProjectDropdown();
        } else {
            uiModule.displaySessionStatus("Project name is required to save.", false);
        }
    });

    // Config Management Listeners
    addAgentButton?.addEventListener('click', () => uiModule.openAgentModal()); // Open modal for adding

    agentForm?.addEventListener('submit', async (event) => {
        event.preventDefault();
        const agentId = document.getElementById('edit-agent-id').value || document.getElementById('agent-id').value;
        const isEditing = !!document.getElementById('edit-agent-id').value;
        const configData = {
            provider: document.getElementById('provider').value,
            model: document.getElementById('model').value,
            persona: document.getElementById('persona').value || 'Assistant Agent',
            temperature: parseFloat(document.getElementById('temperature').value) || 0.7,
            system_prompt: document.getElementById('system_prompt').value || 'You are a helpful assistant.',
            // Add any extra parameters here if needed in the future
        };

        let success;
        if (isEditing) {
            success = await apiClient.updateAgentConfig(agentId, configData);
        } else {
            const createData = { agent_id: agentId, config: configData };
            success = await apiClient.createAgentConfig(createData);
        }

        if (success) {
            uiModule.closeModal('agent-modal');
            await uiModule.refreshConfigList(); // Refresh list after saving
        } else {
            alert(`Failed to ${isEditing ? 'update' : 'add'} agent configuration. Check console for details.`);
        }
    });

     refreshConfigButton?.addEventListener('click', uiModule.refreshConfigList);

     // Initial population of dynamic elements
     uiModule.populateProjectDropdown(); // Populate projects on load
     uiModule.refreshConfigList(); // Populate static config on load
}

export const eventHandler = {
    initializeEventListeners,
    handleWebSocketMessage,
    handleSendMessage // Expose if needed elsewhere, though likely internal
};
