# START OF FILE src/agents/agent_tool_parser.py
import re
import html
import logging
from typing import List, Dict, Tuple, Any, Optional, Pattern

# Import BaseTool definition for type hinting tool schema
from src.tools.base import BaseTool

logger = logging.getLogger(__name__)

def find_and_parse_xml_tool_calls(
    text_buffer: str,
    tools: Dict[str, BaseTool], # Pass the registered tools dict
    raw_xml_pattern: Optional[Pattern], # Pass compiled patterns
    markdown_xml_pattern: Optional[Pattern], # Pass compiled patterns
    agent_id: str # For logging
    ) -> List[Tuple[str, Dict[str, Any], Tuple[int, int]]]:
    """
    Finds *all* occurrences of valid XML tool calls (raw or fenced)
    in the text_buffer, avoiding nested matches. Parses them and returns validated info.
    Validates ONLY parameters marked as universally required=True in the tool schema.
    Action-specific validation happens within the tool's execute method.

    Args:
        text_buffer (str): The text content generated by the LLM.
        tools (Dict[str, BaseTool]): Dictionary mapping tool names to tool instances.
        raw_xml_pattern (Optional[Pattern]): Compiled regex for raw <tool>...</tool>.
        markdown_xml_pattern (Optional[Pattern]): Compiled regex for ```<tool>...</tool>```.
        agent_id (str): The ID of the agent whose buffer is being parsed (for logging).

    Returns:
        List[Tuple[str, Dict[str, Any], Tuple[int, int]]]: A list of tuples, where each tuple contains:
            - tool_name (str): The validated name of the tool found.
            - tool_args (Dict[str, Any]): A dictionary of parsed arguments.
            - span (Tuple[int, int]): The start and end indices of the matched tool call block.
    """
    if not text_buffer: return []
    buffer_content = text_buffer.strip() # Strip buffer first
    logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Checking stripped buffer for XML tool calls (Len: {len(buffer_content)}):\n>>>\n{buffer_content}\n<<<")
    found_calls = []; processed_spans = set()

    def is_overlapping(start, end):
        for proc_start, proc_end in processed_spans:
            if max(start, proc_start) < min(end, proc_end): return True
        return False

    # Inner helper function for parsing logic
    def parse_single_match(match, is_markdown):
         match_start, match_end = match.span()
         for proc_start, proc_end in processed_spans:
              if max(match_start, proc_start) < min(match_end, proc_end): logger.debug(f"[PARSE_DEBUG] Skipping overlapping match at ({match_start}, {match_end})"); return None
         xml_block_to_parse = ""; tool_name_from_outer_match = ""
         if is_markdown: xml_block_to_parse = match.group(1).strip(); tool_name_from_outer_match = match.group(2)
         else: xml_block_to_parse = match.group(0).strip(); tool_name_from_outer_match = match.group(1)
         try:
             tool_name = next((name for name in tools if name.lower() == tool_name_from_outer_match.lower()), None)
             if not tool_name: logger.warning(f"[PARSE_DEBUG] Agent {agent_id}: Found <{tool_name_from_outer_match}> but no matching tool registered."); return None
             if not raw_xml_pattern: logger.error("[PARSE_DEBUG] Raw XML tool call pattern not provided to parser!"); return None
             inner_match = raw_xml_pattern.search(xml_block_to_parse)
             if not inner_match: logger.warning(f"[PARSE_DEBUG] Agent {agent_id}: Could not parse inner content: '{xml_block_to_parse}'"); return None
             inner_tool_name, inner_content = inner_match.groups()
             if inner_tool_name.lower() != tool_name_from_outer_match.lower(): logger.warning(f"[PARSE_DEBUG] Agent {agent_id}: Tool name mismatch ({tool_name_from_outer_match} vs {inner_tool_name})."); return None

             logger.info(f"Agent {agent_id}: Detected call for tool '{tool_name}' at span ({match_start}, {match_end}) (MD: {is_markdown})")

             # Parse parameters
             tool_args = {}; param_pattern = r"<(\w+?)\s*>([\s\S]*?)</\1>"; param_matches = re.findall(param_pattern, inner_content, re.DOTALL | re.IGNORECASE)
             for param_name, param_value_escaped in param_matches: tool_args[param_name] = html.unescape(param_value_escaped.strip()) # Store original case
             logger.info(f"Agent {agent_id}: Parsed args for '{tool_name}': {tool_args}")

             # --- Simplified Universal Parameter Validation ---
             tool_schema = tools[tool_name].get_schema(); expected_params_dict = {p['name']: p for p in tool_schema.get('parameters', [])}
             missing_required = []
             provided_arg_keys_lower = {k.lower() for k in tool_args.keys()} # Get lowercase keys of provided args

             for p_name, p_info in expected_params_dict.items():
                 # Check if a parameter marked as required=True in the schema is missing
                 if p_info.get('required', True) and p_name.lower() not in provided_arg_keys_lower:
                     missing_required.append(p_name)

             if missing_required:
                 # Log warning but DO NOT return None here - let the tool's execute handle action-specific requirements
                 logger.warning(f"Agent {agent_id}: Missing parameter(s) marked as required in schema for tool '{tool_name}': {missing_required}. Tool execution might fail if action needs them.")
                 # Proceeding anyway, tool execute will handle final validation
             # --- End Simplified Validation ---

             # Basic type validation (optional, can add more robust checks here if needed) - This part is less critical now
             validated_args_for_exec = {}
             for schema_param_name, schema_info in expected_params_dict.items():
                 provided_key_match = next((k for k in tool_args if k.lower() == schema_param_name.lower()), None)
                 if provided_key_match:
                     param_value = tool_args[provided_key_match]
                     expected_type = schema_info['type']
                     try:
                         if expected_type == 'integer': validated_args_for_exec[schema_param_name] = int(param_value)
                         elif expected_type == 'float': validated_args_for_exec[schema_param_name] = float(param_value)
                         elif expected_type == 'boolean': validated_args_for_exec[schema_param_name] = str(param_value).lower() in ['true', '1', 'yes']
                         else: validated_args_for_exec[schema_param_name] = str(param_value)
                     except ValueError:
                         logger.warning(f"Agent {agent_id}: Invalid value type for parameter '{schema_param_name}' (expected {expected_type}) in tool '{tool_name}'. Value: '{param_value}'. Passing as string.")
                         validated_args_for_exec[schema_param_name] = str(param_value) # Pass as string on error
                 # We don't necessarily need to add None for missing optional here, kwargs handles it

             processed_spans.add((match_start, match_end));
             # Return the originally parsed args - the tool's execute method will handle specifics
             return tool_name, tool_args, (match_start, match_end)

         except Exception as parse_err: logger.error(f"Agent {agent_id}: Error parsing params for '{xml_block_to_parse[:100]}...': {parse_err}", exc_info=True); return None
    # End Helper Function

    # --- Find Markdown XML (Unchanged) ---
    markdown_matches = []
    if markdown_xml_pattern:
        logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Searching for MARKDOWN XML...")
        try:
             markdown_matches_found = list(markdown_xml_pattern.finditer(buffer_content))
             logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Found {len(markdown_matches_found)} potential markdown XML matches.")
             for m in markdown_matches_found:
                 parsed = parse_single_match(m, True)
                 if parsed: markdown_matches.append(parsed)
        except Exception as e:
             logger.error(f"Agent {agent_id}: [PARSE_DEBUG] Error during markdown XML finditer: {e}", exc_info=True)

    # --- Find Raw XML (Unchanged) ---
    raw_matches = []
    if raw_xml_pattern:
         logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Searching for RAW XML using pattern: {raw_xml_pattern.pattern} ...")
         raw_matches_found = []
         try:
             raw_matches_found = list(raw_xml_pattern.finditer(buffer_content))
             logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Found {len(raw_matches_found)} potential raw XML matches.")
             for m in raw_matches_found:
                 parsed = parse_single_match(m, False)
                 if parsed: raw_matches.append(parsed)
         except Exception as e:
             logger.error(f"Agent {agent_id}: [PARSE_DEBUG] Error during raw XML finditer: {e}", exc_info=True)

    # Combine, sort, and return
    found_calls = markdown_matches + raw_matches
    found_calls.sort(key=lambda x: x[2][0])
    if not found_calls: logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] No valid XML tool calls found in buffer.")
    else: logger.info(f"Agent {agent_id}: Found {len(found_calls)} valid XML tool call(s) in buffer.")
    return found_calls
