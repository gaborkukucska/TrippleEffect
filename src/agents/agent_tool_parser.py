# START OF FILE src/agents/agent_tool_parser.py
import re
import html
import logging
from typing import List, Dict, Tuple, Any, Optional, Pattern

# Import BaseTool definition for type hinting tool schema
from src.tools.base import BaseTool

logger = logging.getLogger(__name__)

def find_and_parse_xml_tool_calls(
    text_buffer: str,
    tools: Dict[str, BaseTool], # Pass the registered tools dict
    raw_xml_pattern: Optional[Pattern], # Pass compiled patterns
    markdown_xml_pattern: Optional[Pattern], # Pass compiled patterns
    agent_id: str # For logging
    ) -> List[Tuple[str, Dict[str, Any], Tuple[int, int]]]:
    """
    Finds *all* occurrences of valid XML tool calls (raw or fenced)
    in the text_buffer, avoiding nested matches. Parses them and returns validated info.

    Args:
        text_buffer (str): The text content generated by the LLM.
        tools (Dict[str, BaseTool]): Dictionary mapping tool names to tool instances.
        raw_xml_pattern (Optional[Pattern]): Compiled regex for raw <tool>...</tool>.
        markdown_xml_pattern (Optional[Pattern]): Compiled regex for ```<tool>...</tool>```.
        agent_id (str): The ID of the agent whose buffer is being parsed (for logging).

    Returns:
        List[Tuple[str, Dict[str, Any], Tuple[int, int]]]: A list of tuples, where each tuple contains:
            - tool_name (str): The validated name of the tool found.
            - tool_args (Dict[str, Any]): A dictionary of parsed and validated arguments.
            - span (Tuple[int, int]): The start and end indices of the matched tool call block in the original buffer.
    """
    if not text_buffer: return []
    buffer_content = text_buffer.strip() # Strip buffer first
    logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Checking stripped buffer for XML tool calls (Len: {len(buffer_content)}):\n>>>\n{buffer_content}\n<<<")
    found_calls = []; processed_spans = set()

    def is_overlapping(start, end):
        for proc_start, proc_end in processed_spans:
            if max(start, proc_start) < min(end, proc_end): return True
        return False

    # Inner helper function for parsing logic
    def parse_single_match(match, is_markdown):
         match_start, match_end = match.span()
         for proc_start, proc_end in processed_spans:
              if max(match_start, proc_start) < min(match_end, proc_end): logger.debug(f"[PARSE_DEBUG] Skipping overlapping match at ({match_start}, {match_end})"); return None
         xml_block_to_parse = ""; tool_name_from_outer_match = ""
         if is_markdown: xml_block_to_parse = match.group(1).strip(); tool_name_from_outer_match = match.group(2)
         else: xml_block_to_parse = match.group(0).strip(); tool_name_from_outer_match = match.group(1)
         try:
             # Match outer tag name against known tools (case-insensitive)
             tool_name = next((name for name in tools if name.lower() == tool_name_from_outer_match.lower()), None)
             if not tool_name: logger.warning(f"[PARSE_DEBUG] Agent {agent_id}: Found <{tool_name_from_outer_match}> but no matching tool registered."); return None

             # Use raw pattern (passed in) to extract inner content reliably
             if not raw_xml_pattern: logger.error("[PARSE_DEBUG] Raw XML tool call pattern not provided to parser!"); return None
             inner_match = raw_xml_pattern.search(xml_block_to_parse)
             if not inner_match: logger.warning(f"[PARSE_DEBUG] Agent {agent_id}: Could not parse inner content: '{xml_block_to_parse}'"); return None

             # Verify inner tag matches outer tag (case-insensitive check)
             inner_tool_name, inner_content = inner_match.groups()
             if inner_tool_name.lower() != tool_name_from_outer_match.lower(): logger.warning(f"[PARSE_DEBUG] Agent {agent_id}: Tool name mismatch ({tool_name_from_outer_match} vs {inner_tool_name})."); return None

             logger.info(f"Agent {agent_id}: Detected call for tool '{tool_name}' at span ({match_start}, {match_end}) (MD: {is_markdown})")

             # Parse parameters
             tool_args = {}; param_pattern = r"<(\w+?)\s*>([\s\S]*?)</\1>"; param_matches = re.findall(param_pattern, inner_content, re.DOTALL | re.IGNORECASE)
             for param_name, param_value_escaped in param_matches: tool_args[param_name] = html.unescape(param_value_escaped.strip()) # Store original case
             logger.info(f"Agent {agent_id}: Parsed args for '{tool_name}': {tool_args}")

             # Parameter Validation
             validated_args = {}; valid_structure = True; tool_schema = tools[tool_name].get_schema(); expected_params_dict = {p['name']: p for p in tool_schema.get('parameters', [])} # Use original case from schema

             # Check provided args against schema (case-insensitive check for key presence, but validate against original case)
             provided_arg_keys_lower = {k.lower() for k in tool_args.keys()}
             expected_param_keys_lower = {k.lower() for k in expected_params_dict.keys()}

             for schema_param_name, schema_info in expected_params_dict.items():
                 param_name_lower = schema_param_name.lower()
                 if param_name_lower in provided_arg_keys_lower:
                     # Find the original case provided by user for the value lookup
                     original_case_key = next((k for k in tool_args if k.lower() == param_name_lower), schema_param_name)
                     param_value = tool_args[original_case_key]
                     expected_type = schema_info['type']
                     try:
                         if expected_type == 'integer': validated_args[schema_param_name] = int(param_value)
                         elif expected_type == 'float': validated_args[schema_param_name] = float(param_value)
                         elif expected_type == 'boolean': validated_args[schema_param_name] = str(param_value).lower() in ['true', '1', 'yes']
                         else: validated_args[schema_param_name] = str(param_value)
                     except ValueError:
                         logger.warning(f"Agent {agent_id}: Invalid value type for parameter '{schema_param_name}' (expected {expected_type}) in tool '{tool_name}'. Value: '{param_value}'"); valid_structure = False; break
                 elif schema_info.get('required', True):
                      # Handle missing required parameters, EXCEPT provider/model for create_agent
                      is_create_agent = tool_name == "ManageTeamTool" and tool_args.get("action") == "create_agent"
                      is_optional_missing = is_create_agent and schema_param_name in ['provider', 'model']
                      if not is_optional_missing:
                           logger.warning(f"Agent {agent_id}: Missing required parameter '{schema_param_name}' for tool '{tool_name}'.")
                           valid_structure = False; break
                      else:
                           logger.debug(f"Allowing missing optional '{schema_param_name}' for ManageTeamTool create_agent.")

             if not valid_structure: return None # Skip this tool call if validation failed

             # Check for unknown parameters provided
             for provided_key in tool_args:
                 if provided_key.lower() not in expected_param_keys_lower:
                      logger.warning(f"Agent {agent_id}: Unknown parameter '{provided_key}' provided for tool '{tool_name}'. Ignoring.")

             processed_spans.add((match_start, match_end)); return tool_name, validated_args, (match_start, match_end)
         except Exception as parse_err: logger.error(f"Agent {agent_id}: Error parsing params for '{xml_block_to_parse[:100]}...': {parse_err}", exc_info=True); return None
    # End Helper Function

    # --- Find Markdown XML ```<tool>...</tool>``` blocks ---
    markdown_matches = []
    if markdown_xml_pattern:
        logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Searching for MARKDOWN XML...")
        try:
             markdown_matches_found = list(markdown_xml_pattern.finditer(buffer_content))
             logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Found {len(markdown_matches_found)} potential markdown XML matches.")
             for m in markdown_matches_found:
                 parsed = parse_single_match(m, True)
                 if parsed: markdown_matches.append(parsed)
        except Exception as e:
             logger.error(f"Agent {agent_id}: [PARSE_DEBUG] Error during markdown XML finditer: {e}", exc_info=True)

    # --- Find Raw XML <tool>...</tool> blocks ---
    raw_matches = []
    if raw_xml_pattern:
         logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Searching for RAW XML using pattern: {raw_xml_pattern.pattern} ...")
         raw_matches_found = []
         try:
             raw_matches_found = list(raw_xml_pattern.finditer(buffer_content))
             logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] Found {len(raw_matches_found)} potential raw XML matches.")
             for m in raw_matches_found:
                 parsed = parse_single_match(m, False)
                 if parsed: raw_matches.append(parsed)
         except Exception as e:
             logger.error(f"Agent {agent_id}: [PARSE_DEBUG] Error during raw XML finditer: {e}", exc_info=True)

    # Combine, sort, and return
    found_calls = markdown_matches + raw_matches
    found_calls.sort(key=lambda x: x[2][0])
    if not found_calls: logger.debug(f"Agent {agent_id}: [PARSE_DEBUG] No valid XML tool calls found in buffer.")
    else: logger.info(f"Agent {agent_id}: Found {len(found_calls)} valid XML tool call(s) in buffer.")
    return found_calls
